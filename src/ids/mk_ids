#! /usr/bin/perl

sub add_name;
sub add_drv;

# entry: <initial letter>, <hexdigits>, <hexdigits for subentry>, <subsubentry, part1>, <..., part2>
%spec = (
  'bus'   => [ 'B', 2, 0, 0, 0 ],
  'class' => [ 'C', 3, 2, 0, 0 ],
  'eisa'  => [ '',  0, 4, 0, 4 ],
  'pci'   => [ '',  4, 4, 4, 4 ],
);

%tag = (
  'pci'     => 0,
  'eisa'    => 1,
  'usb'     => 2,
  'special' => 3,
  'bus'     => 4,
  'class'   => 5
);


for $f (@ARGV) {
  if(open F, $f) {
    while(<F>) {
      chomp;
      s/\s*$//;
      next if /^\s*[#;]/;
      next if /^$/;

      # SaX Identity file
      if(/^NAME=(.+?)§DEVICE=(.+?)§VID=0x([0-9a-fA-F]+?)§DID=0x([0-9a-fA-F]+?)§SERVER=([^§]+)$/) {

        $id1 = [ $tag{'pci'}, hex($3) ];
        $id2 = [ $tag{'pci'}, hex($4) ];
        $val1 = [ $1 ];
        $val2 = [ $2 ];
        $drv = [ 'x11', [ $5 ] ];

        add_name $val1, $id1;
        add_name $val2, $id1, $id2;
        add_drv $drv, $id1, $id2;

        next;
      }

=head1
      if(/^B\s+([0-9a-fA-F]+)\s*(.*?)$/) {
        $type = 'bus';
        $subkey = undef;
        $$type = add_entry $type, $1, $2, $f, $.;
      }

      elsif(/^C\s+([0-9a-fA-F]+)\s*(.*?)$/) {
        $type = 'class';
        $subkey = undef;
        $$type = add_entry $type, $1, $2, $f, $.;
      }

      elsif(/^([0-9a-fA-F]{4})\s*(.*?)$/) {
        $type = 'pci';
        $subkey = undef;
        $$type = add_entry $type, $1, $2, $f, $.;
      }

      elsif(/^([a-zA-Z_@]{3})\s*(.*?)$/) {
        $type = 'eisa';
        $subkey = undef;
        $$type = add_entry $type, $1, $2, $f, $.;
      }

      elsif($type eq 'class' && /^\t\t/) {
         # not yet
#        if(/\t\t([0-9a-fA-F]+)(\.([0-9a-fA-F]+))?\s*(\[(.*?)\])?\s*(.*?)$/) {
#          add_subsubentry $type, $$type, $subkey, $1, $2, $7, $4, $6, $f, $.;
#        }
#        else {
#          print STDERR "invalid line at $f($.)\n";
#          exit 2;
#        }
      }

      elsif($type eq 'pci' && /^\t\t/) {
        # note: the order is <dev_id:vend_id> here; contrary to eisa
        if(/\t\t([0-9a-fA-F]{4})([0-9a-fA-F]{4})(\.([0-9a-fA-F]+))?\s*(\[(.*?)\])?\s*(.*?)$/) {
          add_subsubentry $type, $$type, $subkey, $1, $2, $7, $4, $6, $f, $.;
        }
        elsif(/\t\t([0-9a-fA-F]{4})\s+([0-9a-fA-F]{4})(\.([0-9a-fA-F]+))?\s*(\[(.*?)\])?\s*(.*?)$/) {
          add_subsubentry $type, $$type, $subkey, $2, $1, $7, $4, $6, $f, $.;
        }
        else {
          print STDERR "invalid line at $f($.)\n";
          exit 2;
        }
      }

      elsif($type eq 'eisa' && /^\t\t/) {
        if(/\t\t([a-zA-Z_@]{3})([0-9a-fA-F]{4})(\.([0-9a-fA-F]+))?\s*(\[(.*?)\])?\s*(.*?)$/) {
          add_subsubentry $type, $$type, $subkey, $1, $2, $7, $4, $6, $f, $.;
        }
        else {
          print STDERR "invalid line at $f($.)\n";
          exit 3;
        }
      }

      elsif(/^\t/) {
        if(/\t([0-9a-fA-F]+)(\.([0-9a-fA-F]+))?\s*(\[(.*?)\])?\s*(.*?)$/) {
          $subkey = add_subentry $type, $$type, $1, $6, $3, $5, $f, $.;
        }
        else {
          print STDERR "invalid line at $f($.)\n";
          exit 4;
        }
      }

      else {
        print STDERR "invalid line at $f($.)\n";
        exit 1;
      }
=cut

    }
    close F
  }
  else {
    print STDERR "failed to open $f\n"
  }
}



exit;

=head1
for (sort keys %spec) {
  dump_entries $_;
}
=cut

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
# returns 1 if id1 > id2, 0 if id1 == id2, -1 if id1 < id2
#
sub cmp_id
{
  my ( $id1, $id2, $res );

  ( $id1, $id2 ) = @_;

  return 0 if !defined($id1) && !defined($id2);

  return -1 if !defined($id1);

  return 1 if !defined($id2);

  $res = $id1->[0] <=> $id2->[0];
  return $res if $res;
  
  $res = ($id1->[1] + $id1->[2]) <=> ($id2->[1] + $id2->[2]);
  return $res if $res;

  $res = $id1->[1] <=> $id2->[1];
  return $res if $res;

  return 0 if !defined($id1[2]) && !defined($id2[2]);

  return -1 if !defined($id1[2]);

  return 1 if !defined($id2[2]);

  return $id1->[2] <=> $id2->[2];
}

sub find_name
{
  my ( $ent, $ind, $id1, $id2 );

  $ent = shift;

  for($ind = 0; $ind < @name; $ind++) {
    next if cmp_id $name[$ind]->[0], $ent->[0];
    next if cmp_id $name[$ind]->[1], $ent->[1];
    next if cmp_id $name[$ind]->[2], $ent->[2];
    next if cmp_id $name[$ind]->[3], $ent->[3];
    return $ind;
  }

  return undef;
}

#
# args: val, id1, id2, id3, id4
#
# id:   ( type, value, range )
# val:  ( name, class )
#
sub add_name
{
  my ( $ent, $ind );

  $ent = [ $_[1], $_[2], $_[3], $_[4], $_[0] ];

  $ind = find_name $ent;

  if(!defined($ind)) {
    push @name, $ent;
  }
  else {
    print STDERR "join $ind\n";
  }
}

#
# args: drv, id1, id2, id3, id4
#
# drv: ( type, [ standard info ], [ extended info ] ) 
#
sub add_drv
{
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub dump_entries
{
  my ($et, @a, @b, @c, $s, $t, $i, $j, $k, $z);
  local $_;

  $et = shift;

  for (sort keys %$et) {
    @a = @{$$et{$_}};
    $i = ${$spec{$et}}[0];
    $i .= " " if $i;
    $k = $a[1];
    $k = substr($k, 0, 1) if $reduced && !${$spec{$et}}[0];
    if(!$i && !$k) { $k = $_ }
    @z = keys %{$a[0]};
    if(!$mini || @z || $a[3] || ${$spec{$et}}[0]) {
      print "$i$_\t$k\n";
    }
    for $s (sort keys %{$a[0]}) {
      @b = @{$a[0]{$s}};
      $i = $b[2];
      $i = ".$i" if $i;
      $j = $b[3];
      $j = "[$j] " if $j;
      $k = $b[1];
      $k = substr($k, 0, 1) if $reduced;
      @z = keys %{$b[0]};
      if(!$mini || @z || $b[3]) {
        print "\t$s$i\t$j$k\n";
        for $t (sort keys %{$b[0]}) {
          @c = @{$b[0]{$t}};
          $i = $c[2];
          $i = ".$i" if $i;
          $j = $c[3];
          $j = "[$j] " if $j;
          $k = $c[1];
          $k = substr($k, 0, 1) if $reduced;
          print "\t\t$t$i\t$j$k\n"
        }
      }
    }
  }
}
# [ { }, $val, $class, $drv, $file, $line ];

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub add_entry
{
  my ($type, $key, $val, $file, $line);
  my ($h, @a);

  ($type, $key, $val, $file, $line) = @_;

  return undef unless exists $spec{$type};

#  print "$type, $key, $val, $file, $line\n";

  if(${$spec{$type}}[1]) {
    $key = hex $key;
    $h = sprintf("%x", $key);
    if(length($h) > ${$spec{$type}}[1]) {
      print STDERR "invalid $type entry: $file($line): $h \"$val\"\n";
      return undef
    }
    $key = sprintf "%0${$spec{$type}}[1]x", $key
  }
  else {
    $key = "\U$key"
  }

  if(exists $$type{$key}) {
    @a = @{$$type{$key}};
    if($val && $a[1] && $val ne $a[1]) {
      print STDERR "$type($key) entry: $file,$line: \"$val\" contradicts $a[4],$a[5]: \"$a[1]\"\n";
      return $key
    }
    if($val) { ${$$type{$key}}[1] = $val; }
  }
  else {
    $$type{$key} = [ { }, $val, undef, undef, $file, $line ];
  }

  return $key;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub add_subentry
{
  my ($type, $entry, $key, $val, $class, $drv, $file, $line);
  my ($a, @a, $h, $i);

  ($type, $entry, $key, $val, $class, $drv, $file, $line) = @_;

  return undef unless exists $spec{$type};

#  print "$type, $entry, $key, $val, $class, $drv, $file, $line\n";

  if(${$spec{$type}}[2]) {
    $key = hex $key;
    $h = sprintf("%x", $key);
    if(length($h) > ${$spec{$type}}[2]) {
      print STDERR "invalid sub$type entry: $file($line): $h \"$val\"\n";
      return undef
    }
    $key = sprintf "%0${$spec{$type}}[2]x", $key
  }

  if($class) {
    $class = hex $class;
    $h = sprintf("%x", $class);
    $i = ${$spec{'class'}}[1] + ${$spec{'class'}}[2];
    if(length($h) > $i) {
      print STDERR "invalid class spec: $file($line): \"$h\"\n";
      return undef
    }
    $class = sprintf "%0${i}x", $class
  }

  $a = ${$$type{$entry}}[0];

  if(exists ${$a}{$key}) {
    @a = @{${$a}{$key}};

    if(
      ($val && $a[1] && $val ne $a[1]) ||
      ($class && $a[2] && $class ne $a[2]) ||
      ($drv && $a[3] && $drv ne $a[3])
    ) {
      print STDERR "sub$type($key) entry: $file,$line: \"$val\" contradicts $a[4],$a[5]: \"$a[1]\"\n";
    }

    if($val && !$a[1]) { ${${$a}{$key}}[1] = $val; }

    if($class && !$a[2]) { ${${$a}{$key}}[2] = $class; }

    if($drv && !$a[3]) { ${${$a}{$key}}[3] = $drv; }

  }
  else {
    ${$a}{$key} = [ { }, $val, $class, $drv, $file, $line ];
  }

  return $key;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub add_subsubentry
{
  my ($type, $entry, $subentry, $key, $key2, $val, $class, $drv, $file, $line);
  my ($a, @a, $h, $i);

  ($type, $entry, $subentry, $key, $key2, $val, $class, $drv, $file, $line) = @_;

  return undef unless exists $spec{$type};

#  print "$type, $entry, $subentry, $key, $key2, $val, $class, $drv, $file, $line\n";

  if(${$spec{$type}}[3]) {
    $key = hex $key;
    $h = sprintf("%x", $key);
    if(length($h) > ${$spec{$type}}[3]) {
      print STDERR "invalid subsub$type entry1: $file($line): $h \"$val\"\n";
      return undef
    }
    $key = sprintf "%0${$spec{$type}}[3]x", $key
  }
  else {
    $key = "\U$key"
  }

  if(${$spec{$type}}[4]) {
    $key2 = hex $key2;
    $h = sprintf("%x", $key2);
    if(length($h) > ${$spec{$type}}[4]) {
      print STDERR "invalid subsub$type entry2: $file($line): $h \"$val\"\n";
      return undef
    }
    $key2 = sprintf "%0${$spec{$type}}[4]x", $key2
  }
  else {
    $key2 = "\U$key2"
  }

  $key .= $key2;

  if($class) {
    $class = hex $class;
    $h = sprintf("%x", $class);
    $i = ${$spec{'class'}}[1] + ${$spec{'class'}}[2];
    if(length($h) > $i) {
      print STDERR "invalid class spec: $file($line): \"$h\"\n";
      return undef
    }
    $class = sprintf "%0${i}x", $class
  }

  $a = ${${$$type{$entry}}[0]}{$subentry}[0];

  if(exists ${$a}{$key}) {
    @a = @{${$a}{$key}};

    if(
      ($val && $a[1] && $val ne $a[1]) ||
      ($class && $a[2] && $class ne $a[2]) ||
      ($drv && $a[3] && $drv ne $a[3])
    ) {
      print STDERR "subsub$type($key) entry: $file,$line: \"$val\" contradicts $a[4],$a[5]: \"$a[1]\"\n";
    }

    if($val && !$a[1]) { ${${$a}{$key}}[1] = $val; }

    if($class && !$a[2]) { ${${$a}{$key}}[2] = $class; }

    if($drv && !$a[3]) { ${${$a}{$key}}[3] = $drv; }

  }
  else {
    ${$a}{$key} = [ { }, $val, $class, $drv, $file, $line ];
  }

  return $key;
}

