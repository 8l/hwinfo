#! /usr/bin/perl

sub eisa_id;
sub eisa_str;
sub cmp_id;
sub cmp_ent;
sub find_name;
sub join_name;
sub add_name;
sub dump_names;
sub dump_nums;
sub mk_short_num;
sub dump_drivers;
sub merge_x;

%tag = (
  'pci'     => 1,
  'eisa'    => 2,
  'usb'     => 3,
  'special' => 4,
  'bus'     => 5,
  'class'   => 6
);

@tag_sort = ( 6, 2, 3, 4, 5, 0, 1 );

$fast = 1;		# use hash to speed up id checking

$get_names = $get_drivers = 1;

# driver info only
if($ARGV[0] eq "-d") { $get_names = undef; shift }

# name info only
if($ARGV[0] eq "-n") { $get_drivers = undef; shift }

# non-compact x11 info
if($ARGV[0] eq "-x") { $chk_x11 = 1; shift }

$lline = 0;
for $f (@ARGV) {
  if(open F, $f) {
    @f = (<F>);

    # file format check
    $format = 'names';
    for (@f) {
      if(/^\t[a-z]\s/) {
        $format = 'drivers';
        last;
      }
    }

    $l = 0;
    undef $sax_version;
    if($format eq 'names') {
      print STDERR "***\n*** \"$f\" has name info\n***\n";

      for (@f) {
        $l++;
        $lline++;
        chomp;
        s/\s*$//;
        next if /^\s*[#;]/;
        next if /^$/;

        # SaX Identity file
        if(/^NAME=(.+?)§DEVICE=(.+?)§VID=0x([0-9a-fA-F]+?)§DID=0x([0-9a-fA-F]+?)§SERVER=([^§]+)(§EXT=([^§]*))?(§OPT=([^§]*))?(§RAW=([^§]*))?$/) {
          #       1            2           3                     4                      5      6     7        8     9        10    11
          $tag = $tag{'pci'};
          $id0 = [ $tag, hex($3) ];
          $id1 = [ $tag, hex($4) ];
          $val1 = [ $1, undef, "$f($l)" ];
          $val2 = [ $2, undef, "$f($l)" ];

          add_name $val1, $id0;
          add_name $val2, $id0, $id1;

          ( $srv, $ext, $opt, $raw ) = ( $5, $7, $9, $11 );
          $sax_tmp = $srv =~ /^3DLABS|MACH64|P9000|RUSH|S3|SVGA|TGA$/ ? 1 : 2;
          $sax_version = $sax_tmp unless defined $sax_version;
          die "line has SaX$sax_tmp format (expected SaX$sax_version): $f($l)\n" if $sax_tmp != $sax_version;

          if($new_drv_idx) { $drv_idx++; undef $new_drv_idx }
        
          push @{$driver[$drv_idx][0]}, [ $id0, $id1 ];
          if($opt) {
            push @{$driver[$drv_idx][1]}, [ 'x', [ $sax_version == 1 ? 3 : 4, $srv, undef, undef, $ext, $opt ] ];
          }
          elsif($ext) {
            push @{$driver[$drv_idx][1]}, [ 'x', [ $sax_version == 1 ? 3 : 4, $srv, undef, undef, $ext ] ];
          }
          else {
            push @{$driver[$drv_idx][1]}, [ 'x', [ $sax_version == 1 ? 3 : 4, $srv ] ];
          }
          push @{$driver[$drv_idx][1][-1][2]}, (split /,/, $raw) if $raw;
          $driver[$drv_idx][1][-1][3] = [ $lline, $l, $f ];
          $drv_idx++;
        }

        elsif(/^B\s+([0-9a-fA-F]+)\s+(.*?)\s*$/) {

          $tag = $tag{'bus'};
          $id1 = undef;
          $id0 = [ $tag, hex($1) ];
          $val = [ $2, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^C\s+([0-9a-fA-F]+)\s+(.*?)\s*$/) {

          $tag = $tag{'class'};
          $id1 = undef;
          $id0 = [ $tag, hex($1) ];
          $val = [ $2, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^([0-9a-fA-F]{4})(\s+(.*?))?\s*$/) {

          $tag = $tag{'pci'};
          $id1 = undef;
          $id0 = [ $tag, hex($1) ];
          $val = [ $3, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^u([0-9a-fA-F]{4})(\s+(.*?))?\s*$/) {

          $tag = $tag{'usb'};
          $id1 = undef;
          $id0 = [ $tag, hex($1) ];
          $val = [ $3, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^s([0-9a-fA-F]{4})(\s+(.*?))?\s*$/) {

          $tag = $tag{'special'};
          $id1 = undef;
          $id0 = [ $tag, hex($1) ];
          $val = [ $3, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^([a-zA-Z_@]{3})(\s+(.*?))?\s*$/) {

          $tag = $tag{'eisa'};
          $id1 = undef;
          $id0 = [ $tag, eisa_id($1) ];
          $val = [ $3, undef, "$f($l)" ];

          add_name $val, $id0;
        }

        elsif(/^\t([0-9a-fA-F]{1,4})(\+([0-9a-fA-F]+))?(\.([0-9a-fA-F]+))?(\s+(.*?))?\s*$/) {

          $range = $3 ? hex($3) : undef;
          $class = $5 ? sprintf("%05x", hex($5)) : undef;
          $id1 = [ $tag, hex($1), $range ];
          $val = [ $7, $class, "$f($l)" ];

          $id1->[2] = 0x10000 - $id1->[1] if $id1->[1] + $id1->[2] > 0x10000;

          die "invalid line: $f($l)\n" unless defined($val->[0]) || defined($val->[1]);

          add_name $val, $id0, $id1;
        }

        elsif($tag == $tag{'class'} && /^\t\t([0-9a-fA-F]+)\s+(.*?)\s*$/) {

          $id2 = [ $tag, hex($1) ];
          $id3 = undef;
          $val = [ $2, undef, "$f($l)" ];

          add_name $val, $id0, $id1, $id2;
        }

        elsif(/^\t\t([0-9a-fA-F]{4})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?(\.([0-9a-fA-F]+))?(\s+(.*?))?\s*$/) {

          $range = $4 ? hex($4) : undef;
          $class = $6 ? sprintf("%05x", hex($6)) : undef;
          $id2 = [ $tag, hex($1) ];
          $id3 = [ $tag, hex($2), $range ];
          $val = [ $8, $class, "$f($l)" ];

          die "invalid line: $f($l)\n" unless defined($val->[0]) || defined($val->[1]);

          add_name $val, $id0, $id1, $id2, $id3;
        }

        elsif(/^\t\t([a-zA-Z_@]{3})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?(\.([0-9a-fA-F]+))?(\s+(.*?))?\s*$/) {

          $range = $4 ? hex($4) : undef;
          $class = $6 ? sprintf("%05x", hex($6)) : undef;
          $id2 = [ $tag, eisa_id($1) ];
          $id3 = [ $tag, hex($2), $range ];
          $val = [ $8, $class, "$f($l)" ];

          die "invalid line: $f($l)\n" unless defined($val->[0]) || defined($val->[1]);

          add_name $val, $id0, $id1, $id2, $id3;
        }

        elsif(/^\t\t([0-9a-fA-F]{4})([0-9a-fA-F]{4})\s+(.*?)\s*$/) {

          # NOTE: subvendor & subdevice ids are reversed!
          $id2 = [ $tag, hex($2) ];
          $id3 = [ $tag, hex($1) ];
          $val = [ $3, undef, "$f($l)" ];

          add_name $val, $id0, $id1, $id2, $id3;
        }

        else {
          die "invalid line: $f($l)\n";
        }
      }
    }

    if($format eq 'drivers') {
      print STDERR "***\n*** \"$f\" has driver info\n***\n";

      for (@f) {
        $l++;
        $lline++;
        chomp;
        s/\s*$//;
        next if /^[#;]/;
        next if /^$/;

        if(/^([us]?)([0-9a-fA-F]{4})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s*$/) {

          if($new_drv_idx) { $drv_idx++; undef $new_drv_idx }

          $range = $5 ? hex($5) : undef;
          $tag = $tag{'pci'};
          $tag = $tag{'usb'} if $1 eq 'u';
          $tag = $tag{'special'} if $1 eq 's';
          $id0 = [ $tag, hex($2) ];
          $id1 = [ $tag, hex($3), $range ];

          push @{$driver[$drv_idx][0]}, [ $id0, $id1 ];
        }

        elsif(/^([a-zA-Z_@]{3})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s*$/) {

          if($new_drv_idx) { $drv_idx++; undef $new_drv_idx }

          $range = $4 ? hex($4) : undef;
          $id0 = [ $tag{'eisa'}, eisa_id($1) ];
          $id1 = [ $tag{'eisa'}, hex($2), $range ];

          push @{$driver[$drv_idx][0]}, [ $id0, $id1 ];
        }

        elsif(/^([us]?)([0-9a-fA-F]{4})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s+([us]?)([0-9a-fA-F]{4})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s*$/) {

          if($new_drv_idx) { $drv_idx++; undef $new_drv_idx }

          $range = $5 ? hex($5) : undef;
          $tag = $tag{'pci'};
          $tag = $tag{'usb'} if $1 eq 'u';
          $tag = $tag{'special'} if $1 eq 's';
          $id0 = [ $tag, hex($2) ];
          $id1 = [ $tag, hex($3), $range ];

          $range = $10 ? hex($10) : undef;
          $id2 = [ $tag, hex($7) ];
          $id3 = [ $tag, hex($8), $range ];

          push @{$driver[$drv_idx][0]}, [ $id0, $id1, $id2, $id3 ];
        }

        elsif(/^([a-zA-Z_@]{3})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s+([a-zA-Z_@]{3})\s+([0-9a-fA-F]{4})(\+([0-9a-fA-F]+))?\s*$/) {

          if($new_drv_idx) { $drv_idx++; undef $new_drv_idx }

          $range = $4 ? hex($4) : undef;
          $id0 = [ $tag{'eisa'}, eisa_id($1) ];
          $id1 = [ $tag{'eisa'}, hex($2), $range ];

          $range = $8 ? hex($8) : undef;
          $id2 = [ $tag{'eisa'}, eisa_id($5) ];
          $id3 = [ $tag{'eisa'}, hex($6), $range ];

          push @{$driver[$drv_idx][0]}, [ $id0, $id1, $id2, $id3 ];
        }

        elsif(/^\t([a-z])\s+(.*?)\s*$/) {

          push @{$driver[$drv_idx][1]}, [ $1, [ (split /\|/, $2) ] ];
          $driver[$drv_idx][1][-1][3] = [ $lline, $l, $f ];
          $new_drv_idx = 1;
        }

        elsif($new_drv_idx && /^\t\t(.*)$/) {
          push @{$driver[$drv_idx][1][-1][2]}, $1;
        }

        else {
          die "invalid line: $f($l)\n";
        }
      }
      $new_drv_idx = 1;
    }

  }
  else {
    die "failed to open $f\n"
  }
}

if($get_names) {
  $struct = "dev";

  @name = sort cmp_ent @name;

  open F, ">hd.names";
  select F;
  dump_names;
  close F;

  open F, ">names.h";
  select F;
  dump_nums;
  close F;

  mk_short_num;
  $short = "_s";

  open F, ">names${short}.h";
  select F;
  dump_nums;
  close F;
}

~select STDOUT;

undef $short;
undef @name_str;
undef @name_ofs;
undef %name_ofs;

if($get_drivers) {
  $struct = "drv";

  merge_x;

  open F, ">hd.drivers";
  select F;
  dump_drivers;
  close F;

  @num = @dnum;

  open F, ">drivers.c";
  select F;
  dump_nums;
  close F;
}

select STDOUT;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

sub eisa_id
{
  my ( $str, $id, $i, $j );

  $str = shift;
  $id = 0;

  die "internal oops" unless length($str) == 3;
  for($i = 0; $i < 3; $i++) {
    $id <<= 5;
    $j = ord substr $str, $i, 1;
    $j -= ord('A') - 1;
    die "internal oops" unless $j >= 0 && $j <= 0x1f;
    $id += $j;
  }
  
  return $id;
}

sub eisa_str
{
  my ( $id, $str );

  $id = shift;

  die "internal oops" unless $id >= 0 && $id <= 0x7fff;

  $str  = chr((($id >> 10) & 0x1f) + ord('A') - 1);
  $str .= chr((($id >>  5) & 0x1f) + ord('A') - 1);
  $str .= chr(( $id        & 0x1f) + ord('A') - 1);

  return $str;
}

#
# returns 1 if id1 > id2, 0 if id1 == id2, -1 if id1 < id2
#
sub cmp_id
{
  my ( $id1, $id2, $res );

  ( $id1, $id2 ) = @_;

  return 0 if !defined($id1) && !defined($id2);

  return -1 if !defined($id1);

  return 1 if !defined($id2);

  $res = $tag_sort[$id1->[0]] <=> $tag_sort[$id2->[0]];
  return $res if $res;
  
  $res = ($id1->[1] + $id1->[2]) <=> ($id2->[1] + $id2->[2]);
  return $res if $res;

  $res = $id1->[1] <=> $id2->[1];
  return $res if $res;

  return 0 if !defined($id1[2]) && !defined($id2[2]);

  return -1 if !defined($id1[2]);

  return 1 if !defined($id2[2]);

  return $id1->[2] <=> $id2->[2];
}

#
# suitable for sort
#
sub cmp_ent
{
  my ($i);

  $i = cmp_id $a->[0], $b->[0];
  return $i if $i;
  
  $i = cmp_id $a->[1], $b->[1];
  return $i if $i;
  
  $i = cmp_id $a->[2], $b->[2];
  return $i if $i;
  
  $i = cmp_id $a->[3], $b->[3];
  
  return $i;
}

sub mk_hash
{
  my ( $ent, $id0, $id1, $id2, $id3 );

  $ent = shift;

  $id0 = "$ent->[0][0].$ent->[0][1].$ent->[0][2]" if defined $ent->[0];
  $id1 = "$ent->[1][0].$ent->[1][1].$ent->[1][2]" if defined $ent->[1];
  $id2 = "$ent->[2][0].$ent->[2][1].$ent->[2][2]" if defined $ent->[2];
  $id3 = "$ent->[3][0].$ent->[3][1].$ent->[3][2]" if defined $ent->[3];

  return "$id0:$id1:$id2:$id3";
}


sub find_name
{
  my ( $ent, $ind, $id1, $id2 );

  $ent = shift;

  if($fast) { return undef unless exists $name_f{mk_hash $ent} }

  for($ind = 0; $ind < @name; $ind++) {
    next if cmp_id $name[$ind]->[0], $ent->[0];
    next if cmp_id $name[$ind]->[1], $ent->[1];
    next if cmp_id $name[$ind]->[2], $ent->[2];
    next if cmp_id $name[$ind]->[3], $ent->[3];
    return $ind;
  }

  return undef;
}

sub join_name
{
  my ( $ent, $new_ent, $val, $new_val );

  ( $ent, $new_ent ) = @_;

  $val = $ent->[4];
  $new_val = $new_ent->[4];

  if(defined $val->[0]) {
    if(defined $new_val->[0]) {
      if($val->[0] ne $new_val->[0]) {
        print STDERR "name conflict: $new_val->[2] vs. $val->[2]: \"$new_val->[0]\" != \"$val->[0]\"\n";
# take the longer entry???
#        if(length($new_val->[0]) > length($val->[0])) {
#          $val->[0] = $new_val->[0];
#          $val->[2] = $new_val->[2];
#        }
      }
#      else {
#        print STDERR "ok0: $new_val->[2] vs. $val->[2]: \"$new_val->[0]\" == \"$val->[0]\"\n";
#      }
    }
  }
  else {
    $val->[0] = $new_val->[0];
    $val->[2] = $new_val->[2];
  }

  if(defined $val->[1]) {
    if(defined $new_val->[1]) {
      if($val->[1] ne $new_val->[1]) {
        print STDERR "class_id conflict: $new_val->[2] vs. $val->[2]: \"$new_val->[1]\" != \"$val->[1]\"\n";
      }
#      else {
#        print STDERR "ok1: $new_val->[2] vs. $val->[2]: \"$new_val->[1]\" == \"$val->[1]\"\n";
#      }
    }
  }
  else {
    $val->[1] = $new_val->[1];
    $val->[2] = $new_val->[2] if defined $val->[1];
  }
}


#
# args: val, id1, id2, id3, id4
#
# id:   ( type, value, range )
# val:  ( name, class )
#
sub add_name
{
  my ( $ent, $ind );

  $ent = [ $_[1], $_[2], $_[3], $_[4], $_[0] ];

  $ind = find_name $ent;

  if(!defined($ind)) {
    push @name, $ent;
    if($fast) { $name_f{mk_hash $ent} = 1 }
  }
  else {
    join_name $name[$ind], $ent;
  }
}

sub name_ofs
{
  my ( $str );

  $str = "$_[0]";

  if(!exists($name_ofs{$str})) {
    if(@name_ofs > 0) {
      push @name_ofs, length($name_str[-1]) + $name_ofs[-1] + 1;
      push @name_str, $str;
    }
    else {
      @name_ofs = ( 0 );
      push @name_str, $str;
    }
    $name_ofs{$str} = $name_ofs[-1];
  }

  return $name_ofs{$str};
}

sub id2str
{
  my ( $i, $j, $k, $level, $id, $val );

  ( $level, $id, $val ) = @_;

  if($level == 0) {
    if($id->[0] == $tag{'pci'}) {
      $i = sprintf "%04x", $id->[1];
    }
    elsif($id->[0] == $tag{'eisa'}) {
      $i = sprintf "%s", eisa_str($id->[1]);
    }
    elsif($id->[0] == $tag{'usb'}) {
      $i = sprintf "u%04x", $id->[1];
    }
    elsif($id->[0] == $tag{'special'}) {
      $i = sprintf "s%04x", $id->[1];
    }
    elsif($id->[0] == $tag{'bus'}) {
      $i = sprintf "B %02x", $id->[1];
    }
    elsif($id->[0] == $tag{'class'}) {
      $i = sprintf "C %03x", $id->[1];
    }
    else {
      die "unknown id format at $val->[2]: $id->[0]\n";
    }
  }
  elsif($level == 2 && $id->[0] == $tag{'eisa'}) {
    $i = sprintf "%s", eisa_str($id->[1]);
  }
  elsif($id->[0] == $tag{'class'}) {
    $i = sprintf "%02x", $id->[1];
  }
  else {
    $i = sprintf "%04x", $id->[1];
  }

  if(defined $id->[2]) {
    $j = sprintf "+%x", $id->[2];
  }

  if(($level == 1 || $level == 3) && defined($val->[1])) {	# class spec
    $k = sprintf ".%s", $val->[1];
  }

  return "$i$j$k";
}

sub id2num
{
  my ( @r, $level, $id, $val );

  ( $level, $id, $val ) = @_;

  $r[0] = ($id->[0] << 16) + $id->[1] + ($level << 29);

  if(defined $id->[2]) {
    push @r, $id->[2] + (4 << 29);
  }

  if(($level == 1 || $level == 3) && defined($val->[1])) {	# class spec
    push @r, hex($val->[1]) + (6 << 29);
  }

  return @r;
}

sub issue_name0
{
  my ( @r, $r, $id, $val, $v );

  ( $id, $val ) = @_;

  $v = id2str 0, $id, $val;
  print "$v\t$val->[0]\n";

  @r = id2num 0, $id, $val;
  for $r (@r) { push @num, $r } 
  $r = name_ofs $val->[0];
  push @num, $r + (5 << 29);
}

sub issue_name1
{
  my ( $id, $val, $v );

  ( $id, $val ) = @_;

  $v = id2str 1, $id, $val;
  
  if(defined $val->[0]) {
    print "\t$v\t$val->[0]\n";
  }
  else {
    print "\t$v\n";
  }

  @r = id2num 1, $id, $val;
  for $r (@r) { push @num, $r } 
  $r = name_ofs $val->[0];
  push @num, $r + (5 << 29);
}

sub issue_name2
{
  my ( $id, $val, $v );

  ( $id, $val ) = @_;

  $v = id2str 2, $id, $val;
  
  print "\t\t$v\t$val->[0]\n";

  @r = id2num 2, $id, $val;
  for $r (@r) { push @num, $r } 
  $r = name_ofs $val->[0];
  push @num, $r + (5 << 29);
}

sub issue_name23
{
  my ( $id2, $id3, $val, $v2, $v3 );

  ( $id2, $id3, $val ) = @_;

  $v2 = id2str 2, $id2, $val;
  $v3 = id2str 3, $id3, $val;
  
  if(defined $val->[0]) {
    print "\t\t$v2 $v3\t$val->[0]\n";
  }
  else {
    print "\t\t$v2 $v3\n";
  }

  @r = id2num 2, $id2, $val;
  for $r (@r) { push @num, $r } 
  @r = id2num 3, $id3, $val;
  for $r (@r) { push @num, $r } 
  $r = name_ofs $val->[0];
  push @num, $r + (5 << 29);
}

sub dump_names
{
  my ( $id0, $id1, $id2, $id3, $i, $j );

  name_ofs "";

  for $n (@name) {
    $i = cmp_id $id0, $n->[0];
    if($i) {
      $id0 = $n->[0];
      $id1 = $id2 = $id3 = undef;
      issue_name0 $id0, $n->[4];
      if(defined($n->[1]) || defined($n->[2]) || defined($n->[3])) {
        die "format oops at $n->[4][2]";
      }
      next;
    }

    $i = cmp_id $id1, $n->[1];
    if($i) {
      $id1 = $n->[1];
      $id2 = $id3 = undef;
      issue_name1 $id1, $n->[4];
      if(defined($n->[2]) || defined($n->[3])) {
        die "format oops at $n->[4][2]";
      }
      next;
    }

    $i = cmp_id $id2, $n->[2];
    $j = cmp_id $id3, $n->[3];
    if($i || $j) {
      $id2 = $n->[2];
      $id3 = $n->[3];
      if($id0->[0] == $tag{'class'}) {
        issue_name2 $id2, $n->[4];
      }
      else {
        issue_name23 $id2, $id3, $n->[4];
      }
      next;
    }
  }
}

sub dump_nums
{
  local ( $_ );
  my ( $i, $j, $s, $sl );

  if($struct eq "drv") {
    print "#include <stdio.h>\n#include \"hd.h\"\n\n";
  }

  printf "unsigned hddb_${struct}_data[%u] = {\n", scalar(@num);
  for($i = 0; $i < @num; $i++) {
    if(($i % 6) == 0) { print "  " }
    printf "0x%08x", $num[$i];
    if($i == @num - 1) {
      print "\n"
    }
    else {
      if(($i % 6) == 5) {
        print ",\n"
      }
      else {
        print ", "
      }
    }
  }
  print "};\n\n";

  if(!$short) {
    $j = length($name_str[-1]) + $name_ofs[-1] + 1;
    for (@name_str) { $s .= "$_\x00" }

    die "internal oops" if length($s) != $j;

    $s =~ s/(["\\])/\\$1/g;
    $s =~ s/\t/\\t/g;
    $s =~ s/\n/\\n/g;
    $s =~ s/([\x00-\x1f])/sprintf("\\%03o", ord($1))/eg;

    $sl = length $s;

    printf "char hddb_${struct}_names[%u] = \"\\\n", $j;
    for($i = 0; $i < $sl; $i += 72) {
      printf "%s\\\n", substr($s, $i, 72)
    }
    print "\";\n\n";
  }

  print "hddb_data_t hddb_$struct = {\n";
  printf "  %u, %u, hddb_${struct}_data,\n", scalar(@num), scalar(@num);
  printf "  %u, %u, %s\n", $j, $j, $short ? "NULL" : "hddb_${struct}_names";
  print "};\n\n";

}


sub mk_short_num
{
  local ( $_ );
  my (@n1, @n2, $v, $t, $i, @id, @r, $l, $w, $j );

  # remove name entries
  for (@num) { push @n1, $_ unless (($_ >> 29) & 7) == 5 }

  #remove bus & class entries
  for (@n1) {
    $v = $_ & ((1 << 29) - 1);
    $f = ($_ >> 29) & 7;
    $t = $v >> 16;
    push @n2, $_ unless $f < 4 && ($t == $tag{'bus'} || $t == $tag{'class'})
  }
  undef @n1;

  # remove everything that gives no class spec

  # the code is rather messy but apparently works; it might still be wrong
  # somehow; but at least it will not leave out data, it's just possible
  # that some entries are added that are superfluous

  $l = $w = 0;
  for (@n2) {
    $v = $_ & ((1 << 29) - 1);
    $f = ($_ >> 29) & 7;

    $l = $f if $f < 4;
    $w = $l if $l < $w;
#    printf "%08x, w = %d, l = %d, j = %d, f = %d\n", $_, $w, $l, $j, $f;
    if($f == 0) {
      $id[0] = $_;
      $id[1] = $id[2] = $id[3] = undef;
      $r[0] = $r[1] = $r[2] = $r[3] = undef;
    }
    elsif($f == 1) {
      $id[1] = $_;
      $id[2] = $id[3] = undef;
      $r[1] = $r[2] = $r[3] = undef;
    }
    elsif($f == 2) {
      $id[2] = $_;
      $id[3] = undef;
      $r[2] = $r[3] = undef;
    }
    elsif($f == 3) {
      $id[3] = $_;
      $r[3] = undef;
    }
    elsif($f == 4) {
      $r[$l] = $_;
    }
    elsif($f == 6) {
      for($j = $w; $j <= $l; $j++) {
#        printf "%08x, w = %d, l = %d, j = %d\n", $id[$j], $w, $l, $j;
        push @n1, $id[$j];
        push @n1, $r[$j] if defined $r[$j];
      }
      $w = $l + 1;
      push @n1, $_;
    }
    else {
      die "internal oops"
    }
  }

  @num = @n1;
}

sub issue_drv
{
  my ( $level, $id, @r );

  ( $level, $id ) = @_;

#  printf "> %u %u:%04x\n", $level, $id->[0], $id->[1];

  @r = id2num $level, $id;
  for $r (@r) { push @dnum, $r }
}

#
# driver info structure:
# @{$driver[$drv_idx]->[0]}: array of refs to [ $id0, $id1, $id2, $id3 ]
# @{$driver[$drv_idx]->[1]}: array of refs to [ info_type , [ info0, ... ], [ xtra_info0, ... ] ]
#
sub dump_drivers
{
  local ( $_ );
  my ( $d, $i, @i, $id0, $id1, $id2, $id3, $v0, $v1, $v2, $v3, $last_ids, $current_ids );

  return unless @driver;

  name_ofs "";

  for $d (@driver) {

    next unless defined $d;

    # first the device ids

    @i = @{$d->[0]};
    die "format oops: no ids?" if @i == 0;

    $id0 = $id1 = $id2 = $id3 = undef;

    $last_ids = 0;
    $current_ids = 0;

    for $i (@i) {
      $current_ids = @{$i};
      
      if(cmp_id $id0, $i->[0]) {
        $id0 = $i->[0];
        $id1 = $id2 = $id3 = undef;
        issue_drv 0, $id0;
      }

      # tricky!
      if(
        cmp_id($id1, $i->[1]) ||
        ($current_ids == 4 && $last_ids < 4) ||
        ($current_ids == 2 && $last_ids > 2)
      ) {
        $id1 = $i->[1];
        $id2 = $id3 = undef;
        issue_drv 1, $id1;
      }

      if(cmp_id $id2, $i->[2]) {
        $id2 = $i->[2];
        $id3 = undef;
        issue_drv 2, $id2;
      }

      if(cmp_id $id3, $i->[3]) {
        $id3 = $i->[3];
        issue_drv 3, $id3;
      }

      die "format oops" unless defined($id0) && defined($id1);
      die "format oops" if defined($id2) && !defined($id3);

      $v0 = id2str 0, $id0;
      $v1 = id2str 1, $id1;
      if(defined($id2)) {
        $v2 = id2str 2, $id2;
        $v3 = id2str 3, $id3;
      }
      else {
        $v2 = $v3 = undef;
      }
      print "$v0 $v1";
      print " $v2 $v3" if defined $v2;
      print "\n";

      $last_ids = $current_ids;
    }


    # now the driver info

    @i = @{$d->[1]};

    for $i (@i) {
      $v0 = $i->[0];
      $v1 = join '|', @{$i->[1]};
      die "format oops" if $v1 eq "";

      push @dnum, (ord($v0) & 0xff) + (6 << 29);

      for ($v1, @{$i->[2]}) {
        push @dnum, name_ofs($_) + (5 << 29);
      }

      print "\t$v0\t$v1\n";
      for (@{$i->[2]}) { print "\t\t$_\n" }
    }
  }
}


#
# suitable for sort of driver info entries
#
sub cmp_drv_ent
{
  my ($i);

  $i = cmp_id $a->[0][0][0], $b->[0][0][0];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][1], $b->[0][0][1];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][2], $b->[0][0][2];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][3], $b->[0][0][3];
  return $i if $i;

  $i = $a->[1][0][3][0] <=> $b->[1][0][3][0];
  
  return $i;
}

sub cmp_drv_ent_ns
{
  my ($i, $a, $b);

  ( $a, $b ) = @_;

  $i = cmp_id $a->[0][0][0], $b->[0][0][0];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][1], $b->[0][0][1];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][2], $b->[0][0][2];
  return $i if $i;
  
  $i = cmp_id $a->[0][0][3], $b->[0][0][3];
  
  return $i;
}

sub cmp_drv_ent_info
{
  local ( $_ );
  my ($i, $a, $b, $x, $y);

  ( $a, $b ) = @_;

  if(!defined($a) || !defined($b)) { return 1 }

  $x = $y = "";
  for ( @{$a->[1]} ) {
    $x .= "$_->[0]\x01\n";
    $x .= join '|', @{$_->[1]};
    $x .= "\x01\n";
    $x .= join "\n", @{$_->[2]};
  }
  for ( @{$b->[1]} ) {
    $y .= "$_->[0]\x01\n";
    $y .= join '|', @{$_->[1]};
    $y .= "\x01\n";
    $y .= join "\n", @{$_->[2]};
  }
#  print ">>$x--$y<<\n";

  return $x eq $y ? 0 : 1;
}

# driver info structure:
# @{$driver[$drv_idx]->[0]}: array of refs to [ $id0, $id1, $id2, $id3 ]
# @{$driver[$drv_idx]->[1]}: array of refs to [ info_type , [ info0, ... ], [ xtra_info0, ... ], [ lline, line_nr, file ] ]

sub merge_x
{
  local ( $_ );
  my ( $d, @xdrv, $id, $id1, $idlist, $idlist1, $x, @x, $y, $i, $j, $k, $dl, @x3, @x4, @other_drvs );

  # step 1: make separate entries
  for $d (@driver) {
    if($d->[1][0][0] eq 'x') {
      for $idlist (@{$d->[0]}) {
        $idlist1 = [ @$idlist ];
        $id = $idlist1->[1];
        $i = $id->[2];
        $i = 1 if $i <= 1;
        $j = 0;
        while($i--) {
          $id1 = [ $id->[0], $id->[1] + $j ];
          $j++;
          $idlist1->[1] = $id1;
          $x = [ @$idlist1 ];
          push @xdrv, [ [ $x ] , [ @{$d->[1]} ] ]
        }
      }
      undef $d;
    }
  }
  @other_drvs = grep { defined } @driver;

  # step 2: sort them by id
  @xdrv = sort cmp_drv_ent @xdrv;

  # step 3: join info for identical ids
  undef $dl;
  for $d (@xdrv) {
    if(defined $dl) {
      if(cmp_drv_ent_ns($dl, $d) == 0) {
        push @{$dl->[1]}, @{$d->[1]};
        undef $d;
      }
    }
    $dl = $d if defined $d;
  }
  @xdrv = grep { defined } @xdrv;

  # step 4: check entries for consistency
  for $d ( @xdrv ) {
    $i = $j = $k = 0;
    undef @x3;
    undef @x4;
    for $x ( @{$d->[1]} ) {
      ( $i++, push(@x3, $x), next ) if $x->[1][0] eq '3';
      ( $j++, push(@x4, $x), next ) if $x->[1][0] eq '4';
      $k++;
    }
    for $x (@x3) {
      $k = 3 if ($x->[1][1] ne $x3[0]->[1][1]) && ($x->[1][2] eq $x3[0]->[1][2])
    }
    for $x (@x4) {
      $k = 4 if ($x->[1][1] ne $x4[0]->[1][1]) && ($x->[1][2] eq $x4[0]->[1][2])
    }
    if($i > 2 || $j > 2 || $k) {
      print "*** Conflicting X11 info! ***\n";
      print STDERR "*** conflicting X11 info: ***:\n";
      @driver = ( $d );
      select STDERR;
      dump_drivers;
      select STDOUT
      # die "*** Fix it! ***\n";
    }
    # step 4a: fix some entries
    @x = @{$d->[1]};
    $k = "";
    for ( @x ) {
      $k .= "\t$_->[0]\t";
      $k .= join '|', @{$_->[1]};
      $k .= "\t# $_->[3][2]($_->[3][1])\n"
    }

    for($i = 0; $i < @x; $i++) {
      for($j = $i + 1; $j < @x; $j++) {
        if(
          defined($x[$i]) && defined($x[$j]) &&
          ($x[$i][1][0] eq $x[$j][1][0]) &&	# XF86 version
          ($x[$i][1][1] eq $x[$j][1][1]) &&	# x11 server
          ($x[$i][1][2] eq $x[$j][1][2])	# 3d support flag
        ) {
          printf STDERR
            "x11 info conflict/duplicate:\n  %s %s\n$k  removing: %s  # %s(%d)\n",
            id2str(0, $d->[0][0][0]), id2str(1, $d->[0][0][1]),
            join("|", @{$x[$j][1]}), $x[$j][3][2], $x[$j][3][1];
          $x[$j] = undef;
        }
      }
    }
    @{$d->[1]} = grep { defined } @x;
  }

  if(!$chk_x11) {
    # step 5: re-join entries
    for($i = 0; $i < @xdrv; $i++) {
      for($j = $i + 1; $j < @xdrv; $j++) {
        if(
          defined($xdrv[$i]) && defined($xdrv[$j]) &&
          cmp_drv_ent_info($xdrv[$i], $xdrv[$j]) == 0
        ) {
          # unite ids!
          $x = $xdrv[$i][0][-1];
          $y = $xdrv[$j][0][-1];
          $k = 0;
          if(
            $x->[0][0] == $y->[0][0] && !$x->[0][2] &&
            !defined($x->[2]) && !defined($y->[2])
          ) {
            if($x->[1][2]) {
              if($x->[1][1] + $x->[1][2] == $y->[1][1]) {
                $x->[1][2]++;
                $k = 1;
              }
            }
            else {
              if($x->[1][1] + 1 == $y->[1][1]) {
                $x->[1][2] = 2;
                $k = 1;
              }
            }
          }
          push @{$xdrv[$i][0]}, @{$xdrv[$j][0]} unless $k;
          $xdrv[$j] = undef;
        }
      }
    }
  }
  @xdrv = grep { defined } @xdrv;

  @driver = ( @other_drvs, @xdrv );
}

