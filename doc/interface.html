<html>
<head>
<title>Hardware Probing Library</title>
</head>

<body>
<h1>Hardware Probing Library</h1>

Author: Steffen Winterfeldt <a href="wfeldt@suse.de">wfeldt@suse.de</a><p>

Current version (8 Feb 2000): 0.60<p>

<h2>Simple Expample</h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;hd.h&gt;

int main()
{
  hd_t *hd;

  /* create and initialize the probing data structue */
  hd_data_t *hd_data = calloc(1, sizeof *hd_data);

  /* go for a 'default' probing */
  hd_set_probe_feature(hd_data, pr_default);

  /* do the actual probing */
  hd_scan(hd_data);  

  /* print all hardware data to the terminal */
  for(hd = hd_data-&gt;hd; hd; hd = hd-&gt;next) hd_dump_entry(hd_data, hd, stdout);

  return 0;
}
</pre>

<h2>Reference</h2>

<h3>General Remarks</h3>

The probing library allocates a lot of memory during the probing process. To
not confuse it, it is assumed that you do not free any memory allocated by
the library except using the <code>hd_free_*</code> functions described
below.<p>

<h3>Name/Driver Database</h3>

To associate the hardware with a name and with driver information,
<code>libhd</code> uses two databases.<p>

The first assigns device/vendor names to device/vendor ids. Additionally,
the device's class code can be stored.<p>

The second assigns driver info to device/vendor ids. More than one driver
info can be given, specifying alternative methods to activate a device.<p>

Both databases are compiled into <code>libhd</code>. But you can
<strong>extend</strong> these data using simple text files:
<code>hd.names</code> &amp; <code>hd.drivers</code>. The info from these
files takes precedence over the compiled-in data.<p>

<h3>Functions</h3>

<code><strong>void hd_scan(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Do the actual hardware probing. <code>*hd_data</code> must be properly
initialized before.<br>
The hardware data is returned as a linked list of <a href="#hd_t"><code>hd_t</code></a>
elements. The start of the list is in <code>hd_data-&gt;hd</code>.<p>

<code><strong>void hd_set_probe_feature(<a href="#hd_data_t">hd_data_t</a> *hd_data, <a href="#enum@probe_feature">enum probe_feature</a> feature)</strong></code><br>
<code><strong>void hd_clear_probe_feature(<a href="#hd_data_t">hd_data_t</a> *hd_data, <a href="#enum@probe_feature">enum probe_feature</a> feature)</strong></code><p>

Activate resp. deactivate a probing feature.<br>
For convenience, two special features <code>pr_all</code> and
<code>pr_default</code> have been defined. <code>pr_all</code> activates all probing
features; <code>pr_default</code> the most useful features.<p>

<code><strong>void hd_probe_feature(<a href="#hd_data_t">hd_data_t</a> *hd_data, <a href="#enum@probe_feature">enum probe_feature</a> feature)</strong></code><p>

Tests if a probing feature is activated.<br>
Returns 1 if and 0 if it is not.<p>

<code><strong>char *hd_probe_feature_by_value(<a href="#enum@probe_feature">enum probe_feature</a> feature)</strong></code><br>
<code><strong><a href="#enum@probe_feature">enum probe_feature</a> hd_probe_feature_by_name(char *name)</strong></code><p>

Gives the name of a probing feature resp. converts a string to the internal
representation of a feature. These functions are useful if you want to
interactively (de-)activate some features.<br>
They return <code>NULL</code> resp. <code>0</code> if the argument is not valid.<p>
<p>

<code><strong><a href="#hd_t">hd_t</a> *hd_cd_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, int rescan)</strong></code><br>
<code><strong><a href="#hd_t">hd_t</a> *hd_disk_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, int rescan)</strong></code><br>
<code><strong><a href="#hd_t">hd_t</a> *hd_net_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, int rescan)</strong></code><p>

Return a list of CDROM/disk/network entries only. <code>rescan</code> can have one
of these values:
<ul>
  0: no re-probe, just return the list<br>
  1: re-probe the hardware before building the list<br>
  2: similar to 1, but return only devices that have not already been returned in a
     previous call with rescan == 2<br>
  3: exactly as 2: returns the new stuff since the last call with rescan == 2
     (use this if you need the list more than once)<br>
</ul>
<p>

<code><strong><a href="#hd_t">hd_t</a> *hd_base_class_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned base_class)</strong></code><br>
<code><strong><a href="#hd_t">hd_t</a> *hd_sub_class_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned base_class, unsigned sub_class)</strong></code><p>

Return a list of entries which have the given class/subclass ids.<p>

<code><strong><a href="#hd_t">hd_t</a> *hd_bus_list(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned bus)</strong></code><p>

Return a list of entries attached to the given bus.<p>

<code><strong>int hd_has_special_eide(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return 1 if the kernel should have special eide chipset support, 0 if
not.<p>

<code><strong>int hd_has_pcmcia(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return 1 if PCMCIA is supported, 0 if not.<p>

<code><strong>int hd_apm_enabled(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return 1 if APM support is enabled, 0 if it is disabled.<p>

<code><strong>int hd_smp_support(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return 1 if SMP is supported, 0 if not. (Note: has nothing to do with the number of
processors <em>actually</em> installed.)<p>

<code><strong><a href="#enum@cpu_arch">enum cpu_arch</a> hd_cpu_arch(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return the processor architecture.<p>

<code><strong><a href="#enum@boot_arch">enum boot_arch</a> hd_boot_arch(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Return the boot method to use.<p>

<a name=hd_boot></a>
<code><strong>unsigned hd_boot_disk(<a href="#hd_data_t">hd_data_t</a> *hd_data, int *matches)</strong></code><p>

Returns the boot hardware index of the boot disk. Use
<a href="#hd_idx"><code>hd_get_device_by_idx()</code></a> to obtain the actual hardware
data structure.<br>
Returns 0 if the boot disk could not be determined.<br>
If matches is not <code>NULL</code>, it contains the number of disks that could possibly
be the boot disk. This is normally either 0 or 1 but could in some cases be &gt;1. In that
case, <a href="#hd_boot"><code>hd_boot_disk()</code></a> returns the first hardware entry that might be the boot device.
<p>

<a name=hd_idx></a>
<code><strong><a href="#hd_t">hd_t</a> *hd_get_device_by_idx(<a href="#hd_data_t">hd_data_t</a> *hd_data, int idx)</strong></code><p>

Returns the hardware data structure with the index <code>idx</code> or <code>NULL</code>
if no such entry exists. Two hardware entries are identical if they have the same
index.<p>

<code><strong><a href="#driver_info_t">driver_info_t</a> *hd_driver_info(<a href="#hd_data_t">hd_data_t</a> *hd_data, <a href="#hd_t">hd_t</a> *hd)</strong></code><p>

Return the driver info for a particular hardware item or <code>NULL</code>
if no info is available.<p>

Note that the driver info is actually a linked list so that you possibly get
more than one info for the device. These infos describe alternative methods to
activate the device. The preferred methods are at the top of the list.<p>

<code><strong>char *hd_bus_name(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned bus)</strong></code><br>
<code><strong>char *hd_vendor_name(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned vendor_id)</strong></code><br>
<code><strong>char *hd_device_name(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned vendor, unsigned device)</strong></code><br>
<code><strong>char *hd_sub_device_name(<a href="#hd_data_t">hd_data_t</a> *hd_data, unsigned vendor, unsigned device, unsigned subvendor, unsigned subdevice)</strong></code><p>

These functions convert various ids to strings. If an id could not be found,
<code>NULL</code> is returned.<br>
The returned strings are valid only til the next call to
<code>hd_scan()</code>.<p>

<code><strong>char *hd_class_name(<a href="#hd_data_t">hd_data_t</a> *hd_data, int level, unsigned base_class, unsigned sub_class, unsigned prog_if)</strong></code><p>

Look up a class name. <code>level</code> specifies the amount of valid arguments:
<ul>
1 - only <code>base_class</code><br>
2 - <code>base_class &amp; sub_class</code><br>
3 - <code>base_class &amp; sub_class & prog_if</code>.<br>
</ul>
<p>

If no name was found, <code>NULL</code> is returned. (Note: Typically used with
<code>level = 3</code>).<p>

<code><strong>void hd_dump_entry(<a href="#hd_data_t">hd_data_t</a> *hd_data, <a href="#hd_t">hd_t</a> *hd, FILE *f)</strong></code><p>

Write (a text version of) the hardware entry to a file.<p>

<code><strong><a href="#hd_data_t">hd_data_t</a> *hd_free_hd_data(<a href="#hd_data_t">hd_data_t</a> *hd_data)</strong></code><p>

Free all memory associated with <code>*hd_data</code>, but
<strong>not</strong> <code>*hd_data</code> itself.<br>
Returns <code>NULL</code> just for convenience.<p>

<code><strong><a href="#hd_t">hd_t</a> *hd_free_hd_list(<a href="#hd_t">hd_t</a> *hd)</strong></code><p>

Free all memory associated with the list starting at <code>*hd</code> (including
<code>*hd</code> itself).<br>
Returns <code>NULL</code> just for convenience.<p>

<code><strong><a href="#driver_info_t">driver_info_t</a> *hd_free_driver_info(<a href="#driver_info_t">driver_info_t</a> *di)</strong></code><p>

Free all memory associated with the driver info data (including
<code>*di</code> itself).<br>
Returns <code>NULL</code> just for convenience.<p>

<h3>Data Structures</h3>

<a name=hd_data_t></a>
<pre>
typedef struct {
  enum probe_feature probe;     /* bitmask of probing features */
  hd_t *hd;                     /* the hardware list */

  /* a callback to indicate that we are still doing something... */
  void (*progress)(char *pos, char *msg);
  
  char *log;                    /* log messages */
  unsigned debug;               /* debug flags */
} hd_data_t
</pre>

<a name=hd_t></a>
<pre>
typedef struct s_hd_t {
  struct s_hd_t *next;          /* pointer to next hd_t entry */
  unsigned idx;                         /* unique index, starting at 1 */
  unsigned bus, slot, func;
  unsigned base_class, sub_class, prog_if;
  unsigned dev, vend, sub_dev, sub_vend, rev;
  unsigned compat_dev, compat_vend;

  char *dev_name, *vend_name, *sub_dev_name, *sub_vend_name,
       *rev_name, *serial;

  unsigned attached_to;         /* idx field of 'parent' entry */
  char *unix_dev_name;          /* name of special device file, if any */

  unsigned module, line, count; /* place where the entry was created */

  hd_res_t *res;
  hd_detail_t *detail;
} hd_t
</pre>

<a name=enum@probe_feature></a>
<pre>
enum probe_feature {
  pr_default = 1, pr_memory, pr_pci, pr_pci_range, pr_pci_ext, pr_isapnp,
  pr_cdrom, pr_cdrom_info, pr_net, pr_floppy, pr_misc, pr_misc_serial,
  pr_misc_par, pr_misc_floppy, pr_serial, pr_cpu, pr_bios, pr_monitor,
  pr_mouse, pr_ide, pr_scsi, pr_usb, pr_adb, pr_modem, pr_parallel,
  pr_all                /* pr_all must be the last */
</pre>

<ul>
  <li><code>pr_all</code>: activate just everything<br>
  <li><code>pr_default</code>: activate the most useful features; leave out
  those that can easily cause the probing to hang<br>
  <li><code>pr_memory</code>: get main memory size<br>
  <li><code>pr_pci</code>: add all pci devices<br>
  <li><code>pr_pci_range</code>: add the i/o and memory <em>ranges</em> for
  the pci devices, too; this involves temporarily re-programming the pci
  devices; excluded by <code>pr_default</code><br>
  <li><code>pr_pci_ext</code>: read the extended pci config space, too;
  causes problems with <em>some</em> hardware; excluded by
  <code>pr_default</code><br>
  <li><code>pr_isapnp</code>: add all isa plug &amp; play devices
  (ix86 &amp; axp only)<br>
  <li><code>pr_cdrom</code>: add cdrom devices<br>
  <li><code>pr_cdrom_info</code>: try to read the cdrom and get the
  info from the isao9660 file system<br>
  <li><code>pr_net</code>: add network devices<br>
  <li><code>pr_floppy</code>: go through <code>/proc/nvram</code> and
  add all floppy drives listed there<br>
  <li><code>pr_misc</code>: add basic system components, add resources
  from <code>/proc/{ioports,interrupts,dma}</code><br>
  <li><code>pr_misc_serial</code>: activate the serial support before
  doing the <code>pr_misc</code> stuff<br>
  <li><code>pr_misc_par</code>: activate the parallel support before
  doing the <code>pr_misc</code> stuff<br>
  <li><code>pr_misc_floppy</code>: activate the floppy before
  doing the <code>pr_misc</code> stuff; this includes actually
  <em>reading</em> the floppy<br>
  <li><code>pr_serial</code>: add serial devices from <code>/proc/tty</code><br>
  <li><code>pr_cpu</code>: add cpu entries<br>
  <li><code>pr_bios</code>: add bios info (ix86 only): basically vesa &amp; apm<br>
  <li><code>pr_monitor</code>: add monitor info<br>
  <li><code>pr_mouse</code>: add mouse info (ps/2 &amp; serial)<br>
  <li><code>pr_ide</code>: add ide devices<br>
  <li><code>pr_scsi</code>: add scsi devices<br>
  <li><code>pr_usb</code>: add usb devices<br>
  <li><code>pr_adb</code>: add adb devices (ppc only)<br>
  <li><code>pr_modem</code>: add (serial) modems<br>
  <li><code>pr_parallel</code>: add parallel port devices info (printer)<br>
</ul>


<a name=enum@cpu_arch></a>
<pre>
enum cpu_arch {
  arch_unknown = 0,
  arch_intel, arch_alpha, arch_sparc, arch_sparc64, arch_ppc, arch_68k
}
</pre>

<a name=enum@boot_arch></a>
<pre>
enum boot_arch {
  boot_unknown = 0,
  boot_lilo, boot_milo, boot_aboot, boot_silo, boot_ppc
}
</pre>

<pre>
/* device driver info types */
enum driver_info_type {
  di_any, di_display, di_module, di_mouse, di_x11
};

/* unspecific info */
typedef struct {
  union driver_info_u *next;
  enum driver_info_type type;           /* driver info type */
  str_list_t *hddb0, *hddb1;            /* the actual driver database entries */
} driver_info_any_t;

/* display (monitor) info */
typedef struct {
  union driver_info_u *next;
  enum driver_info_type type;           /* driver info type */
  str_list_t *hddb0, *hddb1;            /* the actual driver database entries */
  unsigned width, height;               /* max. useful display geometry */
  unsigned min_vsync, max_vsync;        /* vsync range */
  unsigned min_hsync, max_hsync;        /* hsync range */
  unsigned bandwidth;                   /* max. pixel clock */
} driver_info_display_t;

/* module info */
typedef struct {
  union driver_info_u *next;
  enum driver_info_type type;           /* driver info type */
  str_list_t *hddb0, *hddb1;            /* the actual driver database entries */
  unsigned active:1;                    /* if module is currently active */
  unsigned modprobe:1;                  /* modprobe or insmod  */
  char *name;                           /* module name */
  char *mod_args;                       /* additional module args */
  char *conf;                           /* conf.modules entry, if any (e.g. for sb.o) */
} driver_info_module_t;

/* mouse protocol info */
typedef struct {
  union driver_info_u *next;
  enum driver_info_type type;           /* driver info type */
  str_list_t *hddb0, *hddb1;            /* the actual driver database entries */
  char *xf86;                           /* the XF86 protocol name */
  char *gpm;                            /* dto, gpm */
} driver_info_mouse_t;

/* X11 server info */
typedef struct {
  union driver_info_u *next;
  enum driver_info_type type;           /* driver info type */
  str_list_t *hddb0, *hddb1;            /* the actual driver database entries */
  char *server;                         /* the server name */
  char *x3d;                            /* 3D info */
  struct {
    unsigned all:5;                     /* the next 5 entries combined */
    unsigned c8:1, c15:1, c16:1, c24:1, c32:1;
  } colors;                             /* supported color depths */
  unsigned dacspeed;                    /* max. ramdac clock */
} driver_info_x11_t;

<a name=driver_info_t></a>
/*
 * holds device driver info
 */
typedef union driver_info_u {
  union driver_info_u *next;
  driver_info_any_t any;
  driver_info_module_t module;
  driver_info_mouse_t mouse;
  driver_info_x11_t x11;
  driver_info_display_t display;
} driver_info_t;
</pre>


</body>
</html>

